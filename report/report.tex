\documentclass[11pt]{article}
\usepackage[paper=letterpaper,margin=1in]{geometry}
\usepackage{graphics}
\usepackage{epsfig}
\usepackage{arcs}
\usepackage{fontenc}
\usepackage{alltt}
\usepackage{amssymb,amsfonts,epsf,url}
\usepackage{graphicx}
\usepackage{pstricks,pstricks-add}
\usepackage{pst-node}
\usepackage{pst-coil}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{verbatim}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{pstricks,pstricks-add,xcolor}
\usepackage{pst-node}
\usepackage{pst-coil}
\usepackage{tikz}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{observation}{Observation}
\newtheorem{case}[theorem]{Case}
\newtheorem{subcase}[theorem]{SubCase}
\newtheorem{transrule}[theorem]{TransRule}
\newtheorem{branchrule}[theorem]{BranchRule}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{assumption}[theorem]{Assumption}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{reduction}{Reduction Rules}[section]
\renewcommand{\labelenumi}{\arabic{enumi}.}
\renewcommand{\labelenumii}{\arabic{enumi}.\arabic{enumii}.}
\renewcommand{\labelenumiii}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}.}
\renewcommand{\labelenumiv}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}.\arabic{enumiv}.}
\newlength{\alginputwidth}
\newlength{\algboxwidth}
\newcommand{\alginput}[1]{\makebox[1.5cm][l]{ {\sc Input:}} \parbox[t]{\alginputwidth}{{\it #1}}}
\newcommand{\algoutput}[1]{\makebox[1.5cm][l]{ {\sc Output:}} \parbox[t]{\alginputwidth}{{\it #1}}}
\newcommand{\algtitle}[1]{\underline{Algorithm \ {\bf #1}} \vspace*{1mm}\\}
\newcommand{\inlinecode}{\texttt}
\newsavebox{\algbox}
\newsavebox{\captionbox}
\newenvironment{algorithm}[2]%
    {
        \setlength{\algboxwidth}{\columnwidth}
        \addtolength{\algboxwidth}{-\columnsep}
        \addtolength{\algboxwidth}{-1mm}
        \setlength{\alginputwidth}{\algboxwidth}
        \addtolength{\alginputwidth}{-1.7cm}
        \begin{figure}[tb]
            \vspace*{2mm}
            \centering
            \begin{lrbox}{\captionbox}
                \begin{minipage}[b]{\algboxwidth}
                    \centering
                    \caption{#1}
                    \label{#2}
                \end{minipage}
            \end{lrbox}
            \begin{lrbox}{\algbox}
                \begin{minipage}[b]{\algboxwidth}
                    \footnotesize
                    \vspace*{2mm}
    } % end of begin
    {
                    \vspace*{0.2mm}
               \end{minipage}
            \end{lrbox}
            \fbox{\usebox{\algbox}\hspace*{1mm}}
            \usebox{\captionbox}
            \vspace*{-4mm}
        \end{figure}
    }
\newsavebox{\algcodebox}
\newenvironment{codeblock}%
    {
        \begin{enumerate}
            \setlength{\itemsep}{2pt}
            \setlength{\parsep}{0pt}
            \setlength{\topsep}{0pt}
            \setlength{\parskip}{0pt}
            \setlength{\partopsep}{0pt}
    } % end of begin
    {\end{enumerate}}
\newcommand{\step}{\item}
\newcommand{\paramproblem}[4]{\noindent {\sc #1}
\\
{\bf Given:} #2\\
{\bf Parameter:} #3\\
{\bf Question:} #4}


\newcommand{\YES}{\textup{\textsf{YES}}}
\newcommand{\NO}{\textup{\textsf{NO}}}
\newcommand{\Oh}{{\mathcal O}}
\newcommand{\nat}{\mathbb{N}}

\newcommand{\Pol}{\mbox{$\mathcal P$}}
\newcommand{\NP}{\mbox{$\mathcal{NP}$}}

\def\eg{{\em e.g.}}
\def\cf{{\em cf.}}
\def\ie{{\em i.e.}}
\def\etal{{\em et al.}}



\psset{unit=1pt}

\date{16 March 2017}
\title{Benchmarking Inductive Monopolar Recognition}

\author{{\sc Nathaniel Brengle}\thanks{Address of Author 1. Email: {\tt nathaniel.brengle@gmail.com}}}


\begin{document}

\maketitle

\begin{abstract}
Following Kanj \textit{et al.} \cite{ref1} we implement and benchmark \textsc{Inductive Monopolar Recognition} and a compare its performance to a general \textsc{$\Pi_A,$$\Pi_B$-Recognition} branching algorithm also described by Kanj \textit{et al.}. The two algorithms have the same runtime, $2^{\mathcal{O}(k)}n^{\mathcal{O}(1)}$. Given that the two algorithms each solve the probem of \textsc{Monopolar Recognition} in the same runtime, a benchmark comparison of the two algorithms is a pertinent investigation of their practicality.

\end{abstract}

\pagenumbering{roman}
\pagenumbering{arabic}


\section{Introduction} \label{sec:intro}


\subsection{Motivation and related work}
\label{subsec:motive}
Motivate your work, and review the related work in the literature.

\subsection{Results and techniques}
\label{subsec:results}
The algorithms were implemented in Python 2.7.13 as its a widely used language with a simple type structure strong language-native analysis tools. The executions were benchmarked on a MacBook Pro(Mid 2015) with a 2.8 GHz Intl Core i7 processor and 16 GB 1600 MHz DDR3 Memory. Rather than embrace fully idiomatic Python, several "non-Pythonic" implementations were made for readability. The full source code is available: \url{https://github.com/nbrengle/monopolar_partition/} and pull requests are welcome.

Rather than re-invent the wheel for graph processing, an established scientific graph-theory library was used to handle the graph data structure(s): \inlinecode{NetworkX} v1.11. NetworkX uses dictionaries-of-dictionaries as the underlying structure of graphs, allowing for constant-time retrieval, as well as trivial iteration and introspection. Though \inlinecode{NetworkX} allows for arbitary node values, sequential integer values are used throughout for simplicity.

A set of five graphs of orders ranging from six to 20 were used as benchmarks for the correctness as well as the benchmark. Varying values for \textit{k} were employed on each graph to allow for both intra-graph and inter-graph execution comparison. The \inlinecode{time.time()} module was employed to measure the execution time. This module is the canonical methodology for measuring processor time in Python 2.7.13 on Unix-based architectures. Each combination of graph and parameter value was executed in sets of 3 consisting of 100 executions. The lowest average time of the 3 sets was used as the benchmark for that particular graph-parameter combination.

Additionally results from the Python profiling module \inlinecode{cProfile} are included for the execution on one graph-parameter combination per graph to demonstrate the relative time consumed on a per caller basis. The \inlinecode{cProfile} time results have only hundredths-of-a-second resolution making them undescriptive for single executions of the algorithms. The results obtained are instead for a full set of 300 executions per graph. Rather than average these values, we include them raw as their primary benefit is for the demonstration of the relative computational intensity of the different steps rather than substatively indicative of the performance of the algorithm as a whole. The \inlinecode{cProfile} results have been cleaned, removing system callers from the call list as the profiling data is illustrative rather than substantive. The raw results are available with the source code.

\section{Preliminaries}
\label{sec:prelim}
Introduce the terminologies you use, and review the necessary background.

\section{Section 1}
\label{subsec:structural}
The body of your paper should be structured in sections, where the material in each section has a common theme. For example, if your paper studies different aspects of a problem (\eg, complexity/\NP-hardness, approximation, exact algorithms), then the results pertaining to each aspect can be discussed under a separate section. Also, if you obtain structural results, or develop techniques, that are later used in different parts of the paper, then you may want to put them in a separate section (section 1) at the beginning of your paper.

\section{Concluding remarks}
\label{sec:conclusion}
Summarize in a short paragraph the work you did. Discuss what future work and open questions ensue from your work.

\bibliographystyle{plain}
\bibliography{ref}
See the format of the attached bibliography file for referencing~\cite{ref1}.


\end{document}
